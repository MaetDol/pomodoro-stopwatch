#!/usr/bin/env node
/* bundle-cpp.js
 * - 프로젝트 내부 헤더("...")를 재귀적으로 인라인해서 단일 C++ 파일을 만듭니다.
 * - 시스템/외부 헤더(<...>)는 기본 그대로 유지(옵션으로 인라인 가능).
 * - 이미 처리한 파일은 중복 인라인하지 않음(Include Guard 효과).
 *
 * 사용:
 *   node bundle-cpp.js <entry.cpp|.ino> [includeDir ...] [-o <output>]
 * 옵션:
 *   -o, --out <path>       출력 파일 경로 (기본: amalgamated.cpp)
 *   --inline-system        <...> 헤더도 인라인 시도
 *   --no-strip-pragma-once #pragma once 라인 유지(기본: 제거)
 *   --print-deps           처리 순서(의존성) 출력
 */

"use strict";
const fs = require("fs");
const path = require("path");

const INCLUDE_RE = /^\s*#\s*include\s*([<"])\s*([^">]+?)\s*[>"]\s*.*$/;
const PRAGMA_ONCE_RE = /^\s*#\s*pragma\s+once\b/;

function parseArgs(argv) {
  let out = "amalgamated.cpp";
  let inlineSystem = false;
  let stripPragmaOnce = true;
  let printDeps = false;

  const positional = [];
  for (let i = 0; i < argv.length; i++) {
    const a = argv[i];
    if (a === "-h" || a === "--help") return { help: true };
    else if (a === "-o" || a === "--out") out = argv[++i];
    else if (a === "--inline-system") inlineSystem = true;
    else if (a === "--no-strip-pragma-once") stripPragmaOnce = false;
    else if (a === "--print-deps") printDeps = true;
    else positional.push(a);
  }
  if (positional.length < 1) {
    return { error: "엔트리 파일을 지정해주세요 (예: src/main.cpp)" };
  }
  const entry = positional[0];
  const includeDirs = positional.slice(1);
  return { out, inlineSystem, stripPragmaOnce, printDeps, entry, includeDirs };
}

function fileExists(p) {
  try {
    return fs.existsSync(p) && fs.statSync(p).isFile();
  } catch {
    return false;
  }
}

function resolveInclude(kind, inc, basedir, includeDirs, inlineSystem) {
  // <...>는 기본 유지. --inline-system 시에는 경로 탐색
  if (kind === "<" && !inlineSystem) return null;

  // 1) 현재 파일 기준 상대 경로
  let cand = path.resolve(basedir, inc);
  if (fileExists(cand)) return cand;

  // 2) 지정한 include 디렉터리 목록
  for (const d of includeDirs) {
    cand = path.resolve(d, inc);
    if (fileExists(cand)) return cand;
  }
  return null; // 못 찾으면 원문 라인 그대로 둠
}

function readText(p) {
  return fs.readFileSync(p, "utf8");
}

function bundle(entry, includeDirs, opts) {
  const seen = new Set(); // 중복 인라인 방지
  const out = [];
  const deps = [];

  function processFile(filePath) {
    const abs = path.resolve(filePath);
    if (seen.has(abs)) return;
    seen.add(abs);
    deps.push(abs);

    const basedir = path.dirname(abs);
    const text = readText(abs);
    const lines = text.split(/\r?\n/);

    for (let line of lines) {
      // #pragma once 제거(옵션)
      if (opts.stripPragmaOnce && PRAGMA_ONCE_RE.test(line)) continue;

      const m = line.match(INCLUDE_RE);
      if (m) {
        const kind = m[1]; // '<' 또는 '"'
        const inc = m[2];
        const target = resolveInclude(
          kind,
          inc,
          basedir,
          includeDirs,
          opts.inlineSystem
        );

        if (target) {
          out.push(
            `\n/* ==== begin include "${inc}" from ${path.basename(abs)} ==== */`
          );
          processFile(target);
          out.push(`/* ==== end include "${inc}" ==== */\n`);
          continue;
        }
        // 못 찾은 경우(또는 <...> 유지): 원문 라인 그대로
      }
      out.push(line);
    }
  }

  // includeDirs에 엔트리 파일의 디렉터리를 기본 포함
  const extra = path.dirname(path.resolve(entry));
  const searchDirs = Array.from(
    new Set([extra, ...includeDirs.map((d) => path.resolve(d))])
  );

  out.push("// generated by bundle-cpp.js");
  out.push("// search include dirs:");
  for (const d of searchDirs) out.push(`//   - ${d}`);
  out.push("");

  processFile(entry);

  return { code: out.join("\n"), deps };
}

function main() {
  const arg = parseArgs(process.argv.slice(2));
  if (arg.help) {
    console.log(readText(__filename).split("\n").slice(0, 40).join("\n"));
    process.exit(0);
  }
  if (arg.error) {
    console.error("에러:", arg.error);
    console.error("도움말: node bundle-cpp.js -h");
    process.exit(1);
  }

  const { out, inlineSystem, stripPragmaOnce, printDeps, entry, includeDirs } =
    arg;

  const { code, deps } = bundle(entry, includeDirs, {
    inlineSystem,
    stripPragmaOnce,
  });

  fs.writeFileSync(out, code, "utf8");
  console.log(`✅ wrote ${out}`);
  if (printDeps) {
    console.log("📦 processed files (order):");
    for (const d of deps) console.log(" -", d);
  }
}

if (require.main === module) main();
